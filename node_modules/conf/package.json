{
  "name": "conf",
  "version": "0.8.4",
  "description": "Config library for Nodejs",
  "keywords": [
    "dsl",
    "conf",
    "config",
    "script",
    "general"
  ],
  "homepage": "https://github.com/jfd/node-conf",
  "author": {
    "name": "Johan Dahlberg",
    "email": "dahlberg.johan@gmail.com",
    "url": "https://github.com/jfd/"
  },
  "main": "./conf",
  "repository": {
    "type": "git",
    "url": "git://github.com/jfd/node-conf.git"
  },
  "os": [
    "macos",
    "linux"
  ],
  "engines": {
    "node": ">=0.3.0"
  },
  "readme": "\n# Conf\n\nConf is a general purpose configuration platform for Nodejs. It can be used to create simple config files or even more advance user scripts. \n\nThe config scripts are plain old javascript with a definition layer on top of\nit.\n\n\nHere is an example:\n\n    server\n        hostname  = \"127.0.0.1\"\n        port      = 80\n\n        location = \"/articles\"\n            root = \"/var/www/sites/my_site/articles\"\n            expires = \"30d\"\n        end\n\n        location = \"/home\"\n            redirect = \"/\"\n        end\n    end\n\nThe above example would result in the following JavaScript graph \nwhen parsed:\n\n    { \n      server: { hostname: \"127.0.0.1\"\n              , port: 80\n              , location: [\n                  { url: \"/articles\"\n                  , root: \"/var/www/sites/my_site/articles\"\n                  , exipres: \"30d\"\n                  },\n                  { url: \"/home\"\n                  , redirect: \"/\"\n                  }\n                ]\n              }\n    }\n\nAs mention above, the config scripts is Javascript, so it is possible to mix\nyour DSL with Javascript. This is a powerful feature, which let you do \nstuff like this:\n\n    LOCATIONS = [\"/articles\", \"/comments\", \"/users\"]\n\n    server\n        hostname  = \"127.0.0.1\"\n        port      = 80\n\n        LOCATIONS.forEach(function(path) {\n          location = path\n              root = \"/var/www/sites/my_site\" + path\n              expires = \"30d\"\n          end\n        });\n\n        location = \"/home\"\n            redirect = \"/\"\n        end\n    end\n\n\n# API\n\nThe API is defined by two functions: `createContext` and `createScript`. The\n`createContext` creates a markup that can be used with `createScript`.\n\n### createContext(markup)\n\nConstruct a new config context object. The config context is then used\nto run a config script.\n\nThe `markup` is a data graph, that is used to describe the config script\nlayout. A simple example:\n\n    var conf = require(\"conf\");\n    conf.createContext({\n      host: { type: \"string\", value: \"localhost\" },\n      port: { type: \"number\", value: 8080}\n    });\n\n\nThe first key, `host`, represents a String property with default \nvalue `\"localhost\"`. The second key, `port`, represents a Number property\nwith default value `8080`.\n\nA valid config script for example context above would look\nlook like:\n\n    host = \"10.0.0.1\"\n    port = 80\n\n\nSee the \"Defining context markup\" -section for complete documentation.\n\n\n### createScript(path, [filename])\n\nConstruct a new config script object, from specified path. An optional\n`filename` can be set\n\nThis function is synchronous and throws an exception on read errors.\n\n\n## Script\n\nRepresents a Script.\n\n\n\n### Script.runInContext(context, [env])\n\n\n## RuntimeError\n\nAll errors produced by \"conf\" is derived from the class RuntimeError. The\nRunTimeError class inherits the native Error class.\n\n### RuntimeError.getSimpleMessage\n\nReturns a simplified message, without stack trace information, but with \nerror message and line number. \n\nThe `getSimpleMessage` method is useful when you want to show user what's\nwrong, without showing what happen \"behind-the-scene\".\n\n\n## Defining context markup \n\nThere is 15 different types of fields, each with it's own set of\nproperties. \n\nMany of the types share's a set of properties. For example, `required` can\nbe used with any type. The common properties are:\n\n- `required` set to `true` to indicate that the field is required.\n- `list` indicates that there can be multiply definitions of the field.\n- `strict` indicates that the field value should be validated strictly.\n- `value` sets a default value for the field.\n- `idxignore` indicates that the field should be ignored in an index.\n- `param` has different meaning in different types. See type documentation for implementation.\n- `index` use field in a index.\n- `onenter` callback when entering a section (see section documentation for more details).\n- `onexit` callback when exiting a section (see section documentation for more details).\n\nSome of the types can be used with a \"shortcut\". Shortcuts is used to \nquickly define a property, without adding additionally markup. Here is an\nexample of a shortcut in action:\n\n    conf.createContext({\n      host: String\n    });\n\nThe above example is mapped to:\n\n    conf.createContext({\n      host: { type: \"string\" }\n    }); \n\nIt is also possible to map the type with it's name:\n\n    conf.createContext({\n      host: \"string\"\n    });\n\nA required field can be defined by typing the type name with capitals:\n\n    conf.createContext({\n      host: \"STRING\"\n    });\n\nWhich maps to:\n\n    conf.createContext({\n      host: { type: \"string\", required: true }\n    });\n\nIt is also possible to define a list with shortcut. Just encapsulate with\nbrackets as follows: \n\n    conf.createContext({\n      host: [\"string\"]\n    });\n\n---\n\nThe different types of fields are: `boolean`, `string`, `number`, `array`,\n`object`, `regexp`, `expression`, `path`, `static`, `wildcard` `section`,\n`struct`, `custom`, `bytesize` and `timeunit`.\n\n### boolean\n\nRepresents a boolean value. Valid values in strict mode are \n`true` or `false`. Undefined values is converted to `true` in non-strict\nmode.\n\nThe native class `Boolean` works as a shortcut for the boolean field type.\n\n### string\n\nRepresents a String value. Values, which is not of native type string, are \nconverted to a string object via the `toString` method in non-strict mode.\n\nThe native class `String` works as a shortcut for the string field type.\n\n### number\n\nRepresents a Number value. Values, which is not of native type number, are \nconverted to numbers via the `parseInt` function in non-strict mode.\n\nThe native class `Number` works as a shortcut for the string field type.\n\n### array\n\nRepresents an Array value. Values, which is not of native type array, are\nencapsulated with bracets in non-strict mode.\n\nThe native class `Array` works as a shortcut for the string field type.\n\n### object\n\nRepresents an Object value. All values, except `undefined` and `null`, are\naccepted.\n\nThe native class `Object` works as a shortcut for the string field type.\n\n### regexp\n\nRepresents a RegExp value. String values is converted into RegExp instances\nvia it's constructor in non-strict mode.\n\nThe native class `RegExp` works as a shortcut for the string field type.\n\n### expression\n\nRepresents a string value, that is validated against a RegExp expression.\n\nThe field property Â´param` MUST contain an RegExp instance.\n\nAn expression example:\n\n    createContext({\n      method: { type: \"expression\", param: /^(get|set)$/ }\n    });\n\nA more convenience may be to use expression types shortcut:\n\n    createContext({\n      method: { type: /^(get|set)$/ }\n    });\n\nOr, the even more convenience shortcut:\n\n    createContext({\n      method: /^(get|set)$/\n    });\n\n### path\n\nRepresents a file-system path value, with relative-path support. Values, \nwhich is not of native type String, are converted to a string object via \nthe `toString` method in non-strict mode.\n\nRelative path's is mapped against scripts `workdir` variable.\n\nExample (markup):\n\n    createContext({\n      data_file: { type: \"path\" }\n    });\n\nExample (config):\n\n    data_file = \"./data/data.json\"\n\nResult for example above:\n\n    { data_file: \"/parent_directory_of_config_file/data/data.json\" }\n      \nThis field is currently not supported on Windows.\n\n### static\n\nRepresents a static value. Static values cannot be set, they behave more\nlike traditional `constants`, except that they cannot be accessed in\nthe config file, just the result.\n\nThe field property `value` **must** be set for static fields.\n\nExample:\n\n    createContext({\n      debug: { type: \"static\", value: true }\n    });\n\nWhich results in:\n\n    { debug: true }\n    \n### wildcard\n\nWildcards can contain any kind of value.\n    \n\n### section\n\nRepresents a section. Sections is used to divide fields into groups.\n\nSection's has a set of special properties that can be set:\n\n- `property` sets a default field for the section.\n- `index` creates an index for the section, with specified name. This is\n  useful when the order of section fields is needed.\n- `section` is the shortcut for sections.\n\nSee use-cases in examples below.\n\nThe section scope MUST be closed with the built-in keyword `end` (see \nsection \"Built-in keywords\" for more details) when defining it in a\nconfig file.\n\nThe field property `param` MUST be set for static fields.\n\nA quick example:\n\n    createContext({\n      database: { type: \"section\", param: {\n        port: Number,\n        host: String\n      }}\n    });\n\n    ---\n\n    database\n      port = 8080\n      host = \"127.0.0.1\"\n    end\n\nWhich results in:\n\n    { database: { \n      port: 8080, \n      host: \"127.0.0.1\"\n    }}\n\nOne more convenient way would be to use the `section` shortcut. Here is\nan example that represents the markup above:\n\n    createContext({\n      database: { section: {\n        port: Number,\n        host: String\n      }}\n    });\n\nThere is no need for the `param` property when defining sections with the\nshortcut.\n\n### struct\n\nRepresents a struct. Struct is similar to section's but cannot only\ncontain one child field. The struct is also laking some of the \nspecial properties that section supports. \n\nThe special property `property` is supported though. \n\nNote: The `end` keyword is NOT supported in struct fields.\n\n    createContext({\n      static_server: { type: \"struct\", param: {\n        port: { type: \"static\", value: 8080},\n        host: { type: \"static\", value: \"127.0.0.1\"}\n      }}\n    });\n\n### custom\n\nRepresents a custom value. Custom values are validated with provided \nfunction. \n\nExample:\n\n    function customValue(field, value, runtime) {\n      \n      if (value !== \"value\") {\n        throw new Error(\"Expected value\");\n      }\n      \n      return value;\n    }\n    \n    createContext({\n      my_custom: { type: \"custom\", param: customValue };\n    });\n    \nCustom values also have a shortcut. Just put the validator as type:\n\n    createContext({\n      my_custom: { type: customValue };\n    });\n\n\n### bytesize\n\nRepresents a byte size value. Byte size values is defined by a number or\na string expression.\n\nThe string expression is defined with a number and a suffix. Supported\nsuffixes are:\n\n- `b` represents a byte.\n- `kb` represents a kilobyte (1024 bytes)\n- `mb` represents a megabyte (1024 * 1024 bytes)\n- `gb` represents a gigabyte (1024 * 1024 * 1024 bytes)\n\nHere is an example with a string expression.\n\n    createContext({\n      max_file_size: { type: \"bytesize\" };\n    });\n    \n    ---\n    \n    max_file_size = \"12mb\"\n    \n\n### timeunit\n\nRepresents a time unit value. Time unit values is defined by a number or\na string expression.\n\nThe string expression is defined with a number and a suffix. Supported\nsuffixes are:\n\n- `ms` represents a millisecond.\n- `s` represents a second (1000 milliseconds)\n- `m` represents a minute (60 * 1000 milliseconds)\n- `h` represents an hour (60 * 60 * 1000 milliseconds)\n- `d` represents a day (24 * 60 * 60 * 1000 milliseconds)\n\nHere is an example with a string expression.\n\n    createContext({\n      backup_interval: { type: \"timeunit\" };\n    });\n    \n    ---\n    \n    backup_interval = \"1h\"\n    \nThe return value is always in milliseconds.\n\n## Built-in keywords\n\nThere is two built-in config file keywords, `end` and `include`. The\nkeyword `end` is called as a property while the `include` is called as\na function.\n\n### end\n\nThe keyword `end` is used to close a scope (section). The script-engine\nis automatically closing scopes on end of execution, but it's good to\nalways call `end` anyway.\n\n    section\n        field = \"field value\" \n    end\n\n### include(path)\n\nThe keyword `include` imports another config script and executes it in\ncurrent runtime. The `path` argument must be set and should point\nto the script to include. Relative-paths are accepted.\n\n    include(\"./mime_types.conf\")\n\nIt is also possible to use wildcard patterns to include one ore more\nfiles. Supported special characters are **\"*\"** and **\"?\"**. \n\n    include(\"./sites/*.conf\");\n\nNote: The `include` keyword does not check if config is already included. This could result in a never-ending loop if a config includes it self.\n\n## License\n\nBSD-License.\n\nCopyright (c) Johan Dahlberg 2011\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jfd/node-conf/issues"
  },
  "_id": "conf@0.8.4",
  "dist": {
    "shasum": "dfe65df4cfc9c01668d5857b8a691e67da1e4dbe"
  },
  "_from": "conf@latest",
  "_resolved": "https://registry.npmjs.org/conf/-/conf-0.8.4.tgz"
}
